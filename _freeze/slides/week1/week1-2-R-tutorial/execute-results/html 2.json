{
  "hash": "e5cfbc3fe432fb939a03ae88ea658809",
  "result": {
    "markdown": "---\ntitle: \"Introduction to R\"\n---\n\n\n# Part I\n\nIf you are seeing error messages, please review them and try to understand. It is a good practice for you debug.\n\nIf you are seeing warning messages, please review. Warning messages are typically not fatal. Might be obsolete/deprecated.\n\n## Universal things every R user should know:\n\n### Find which version of R you are using\n\n\n::: {.cell}\n\n```{.r .cell-code}\nR.version\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               _                           \nplatform       aarch64-apple-darwin20      \narch           aarch64                     \nos             darwin20                    \nsystem         aarch64, darwin20           \nstatus                                     \nmajor          4                           \nminor          3.1                         \nyear           2023                        \nmonth          06                          \nday            16                          \nsvn rev        84548                       \nlanguage       R                           \nversion.string R version 4.3.1 (2023-06-16)\nnickname       Beagle Scouts               \n```\n:::\n:::\n\n\n## Packages\n\nR has many tools wrapped in packages, and we often use those tools in our work.\n\nTo use a tool, you need to install it.\n\nThe package used in Data Mining with R is `DMwR2`\n\nIn Windows 11, this shall run okay.\n\nIn Ubuntu 20.04, you might see error. one error requires run `sudo apt-get install libcurl4-openssl-dev` in your terminal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"DMwR2\")\n```\n:::\n\n\nTo see what is in a package, use `help()`. If you do not see documentation, there might be errors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(package=\"DMwR2\")\n```\n:::\n\n\nThe above step takes some time and you need internet connection.\n\nNow the packages are installed in your computer. To use a function in the package, either of the two ways works:\n\n\\(1\\) when you need to use the function frequently, you would want to load it to the memory for your current session by using `library()` function (one RStuido window is one session, if you have multiple RStudio windows open, they are different sessions)\n\n\\(2\\) when you only need to use the function one or twice, you can call the `function/dataset` through the notation `package::functionname`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DMwR2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n```\n:::\n:::\n\n\nNow you can use any function or dataset provided in `DMwR2` by referencing its name directly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(algae) # load algae dataset\nalgae  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 200 × 18\n   season size  speed   mxPH  mnO2    Cl    NO3   NH4  oPO4   PO4  Chla    a1\n   <fct>  <fct> <fct>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 winter small medium  8      9.8  60.8  6.24  578   105   170   50      0  \n 2 spring small medium  8.35   8    57.8  1.29  370   429.  559.   1.3    1.4\n 3 autumn small medium  8.1   11.4  40.0  5.33  347.  126.  187.  15.6    3.3\n 4 spring small medium  8.07   4.8  77.4  2.30   98.2  61.2 139.   1.4    3.1\n 5 autumn small medium  8.06   9    55.4 10.4   234.   58.2  97.6 10.5    9.2\n 6 winter small high    8.25  13.1  65.8  9.25  430    18.2  56.7 28.4   15.1\n 7 summer small high    8.15  10.3  73.2  1.54  110    61.2 112.   3.2    2.4\n 8 autumn small high    8.05  10.6  59.1  4.99  206.   44.7  77.4  6.9   18.2\n 9 winter small medium  8.7    3.4  22.0  0.886 103.   36.3  71    5.54  25.4\n10 winter small high    7.93   9.9   8    1.39    5.8  27.2  46.6  0.8   17  \n# ℹ 190 more rows\n# ℹ 6 more variables: a2 <dbl>, a3 <dbl>, a4 <dbl>, a5 <dbl>, a6 <dbl>,\n#   a7 <dbl>\n```\n:::\n\n```{.r .cell-code}\nmanyNAs(algae) # find rows with too many NAs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  62 199\n```\n:::\n:::\n\n\n`library()` without arguments:\n\nIt will provide you the list of packages installed in different libraries on your computer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary()\n```\n:::\n\n\nShow packages loaded in the current session:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(.packages())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"DMwR2\"     \"stats\"     \"graphics\"  \"grDevices\" \"utils\"     \"datasets\" \n[7] \"methods\"   \"base\"     \n```\n:::\n:::\n\n\nThink of `library()` as a library of all installed packages. `library(packagename)` checks a package out.\n\n`.packages()` shows all checked out packages in the current session.\n\nIf you loaded a package, say `dbplyr`, by mistake, you can detach it from your session using `detach`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dbplyr\") # assuming you have dbplyr installed before \n\n# now you try to check out dplyr, but typed dbplyr by accident\nlibrary(dbplyr) \n(.packages())\n# you realized the mistake, and you don't want this package to be live in this session due to potential conflicts\n# you can detach the package\ndetach(\"package:dbplyr\", unload=TRUE) \n(.packages())\n    \nlibrary(dplyr)#load wanted library\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dbplyr\"    \"DMwR2\"     \"stats\"     \"graphics\"  \"grDevices\" \"utils\"    \n[7] \"datasets\"  \"methods\"   \"base\"     \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"DMwR2\"     \"stats\"     \"graphics\"  \"grDevices\" \"utils\"     \"datasets\" \n[7] \"methods\"   \"base\"     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n\nAnother way to see what packages have been installed in your computer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstalled.packages() \n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n              Package         LibPath                                    \nalphavantager \"alphavantager\" \"/Users/gchism/Library/R/arm64/4.3/library\"\nanytime       \"anytime\"       \"/Users/gchism/Library/R/arm64/4.3/library\"\nassertr       \"assertr\"       \"/Users/gchism/Library/R/arm64/4.3/library\"\n              Version Priority Depends       \nalphavantager \"0.1.3\" NA       \"R (>= 3.3.0)\"\nanytime       \"0.3.9\" NA       \"R (>= 3.2.0)\"\nassertr       \"3.0.0\" NA       \"R (>= 3.1.0)\"\n              Imports                                                                                                                                                                                       \nalphavantager \"dplyr (>= 0.7.0), glue (>= 1.1.1), httr (>= 1.2.1), jsonlite\\n(>= 1.5), purrr (>= 0.2.2.2), readr (>= 1.1.1), stringr (>=\\n1.2.0), tibble (>= 1.3.3), tidyr (>= 0.6.3), timetk (>=\\n0.1.1.1)\"\nanytime       \"Rcpp (>= 0.12.9)\"                                                                                                                                                                            \nassertr       \"dplyr (>= 0.7.0), MASS, methods, stats, utils, rlang (>=\\n0.3.0)\"                                                                                                                            \n              LinkingTo             \nalphavantager NA                    \nanytime       \"Rcpp (>= 0.12.9), BH\"\nassertr       NA                    \n              Suggests                                             Enhances\nalphavantager \"testthat, knitr\"                                    NA      \nanytime       \"tinytest (>= 1.0.0), gettz\"                         NA      \nassertr       \"knitr, testthat, magrittr, rmarkdown, tibble, plyr\" NA      \n              License              License_is_FOSS License_restricts_use\nalphavantager \"GPL (>= 3)\"         NA              NA                   \nanytime       \"GPL (>= 2)\"         NA              NA                   \nassertr       \"MIT + file LICENSE\" NA              NA                   \n              OS_type MD5sum NeedsCompilation Built  \nalphavantager NA      NA     \"no\"             \"4.3.0\"\nanytime       NA      NA     \"yes\"            \"4.3.0\"\nassertr       NA      NA     \"no\"             \"4.3.0\"\n```\n:::\n:::\n\n\nFind out if your installed packages have a newer version on CRAN:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold.packages()\n```\n:::\n\n\nUpdate all your installed packages to the newest version -- this may take a long time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate.packages()\n```\n:::\n\n\nUpdate all your installed packages WITHOUT having to confirm for each package (Note: as this could take a long time, you don't have to practice this command. Do not worry too much if you see warning or failure messages)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate.packages(ask = FALSE)\n```\n:::\n\n\nFind out the namespace/package a function belongs in your installed packages, just type the function name - e.g., function `mean` is in base R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x11f59bca8>\n<environment: namespace:base>\n```\n:::\n:::\n\n\nFind help on a function in an installed package, say `mean()`. If you use R Studio, R documentation on the method `mean()` is display on lower right pane of the window:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(mean)\n```\n:::\n\n\nIf two packages provide a function with the same name and you need to use both functions, use `package::functionname` to differentiate the functions.\n\nWhen you want to see if a package you need to use has already been made, search for it using some keywords:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRSiteSearch('neural networks')\n```\n:::\n\n\n######################################################################### \n\n``` {.r .R}\n#useful controls in R Studio#\n#Ctrl+1  Move focus to the Source Editor.\n#Ctrl+2  Move focus to the Console.\n#Ctrl+l  Clear the Console.\n#Esc     Interrupt R.\n```\n\n## Project and Session Management\n\nUse Project to manage your R scripts and data.\n\nIn RStudio, `File > New Project` to create a new folder on your computer for your project.\n\nMultiple scripts can be created and saved in the project folder, along with data used\n\n`File > Open Project` to resume your work in the workspace.\n\nYour project folder is your current working directory, where you can save your `.R` and `.RData` files.\n\nBut a `.R` file can exist outside a project /project folder.\n\n`Close a Project` in RStudio closes the current project, but still keep the session (RStudio interface is still up)\n\n`Quit Session` closes the current RStudio window.\n\nTyping long and complex commands in a console can be limiting.\n\nYou can type all the commands in a text file and save it, then use \\[1\\] `source('path_to_mycode.R')` to execute the series of commands or \\[2\\] open `mycode.R` in RStudio script tab and execute your commands from there using `Run` or `Source` button.\n\n`Run`: run the code line by line\n\n`Source`: run the entire script\n\nYou often need to save large data objects or function for later use\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(my.function, mydataset, file=\"path_to_mysession.RData\")\nload(\"path_to_mysession.RData\")\n```\n:::\n\n\n## Save all objects\n\nAll objects are saved in `.RData` file in the current working directory for you to load in the future.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave.image()\n```\n:::\n\n\nRun `getwd()` and `setwd()` in RStudio Console to show the current working directory and to set working directory respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n\nsetwd(\"/home/gchism/Documents/523\") # setwd using what you get from getwd()\n\ngetwd()\n```\n:::\n\n\n## R Objects and Variables\n\nVariables are references to some storage locations in computer memory that holds some content (objects) that range from a simple number to an complex model to associate an object (e.g., the number `0.2`) to a variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvat <- 0.2\n```\n:::\n\n\nNow see what `vat` holds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2\n```\n:::\n:::\n\n\nUse `()` to enclose a statement to have the returned values print directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vat <- 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2\n```\n:::\n:::\n\n\nMore examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\ny <- vat * x\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nz <-(y/2)^2\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.25\n```\n:::\n:::\n\n\nAll variables stay alive until you delete it or when your exit R without saving them to list variables currently alive: `ls()` or `objects()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"algae\"           \"algae.sols\"      \"has_annotations\" \"test.algae\"     \n[5] \"vat\"             \"x\"               \"y\"               \"z\"              \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nobjects()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"algae\"           \"algae.sols\"      \"has_annotations\" \"test.algae\"     \n[5] \"vat\"             \"x\"               \"y\"               \"z\"              \n```\n:::\n:::\n\n\nRemove a variable to free memory space:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(vat)\n```\n:::\n\n\n## R Functions\n\nFunctions are a special type of R object designed to carry out some operation. Functions expects some input arguments and outputs results of it operation. R has many functions already, libraries you loaded contains functions you can use, you can also create new functions.\n\nExamples of R functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(4, 5, 6, 12, -4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n\n```{.r .cell-code}\nmean(4, 5, 6, 12, -4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmax(sample(1:100, 30))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 98\n```\n:::\n\n```{.r .cell-code}\nmean(sample(1:100, 30))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 49.26667\n```\n:::\n:::\n\n\nWhy does the same function with the same argument give different results above? Use `help(sample)` to find out what function sample does.\n\nWhat do you expect?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1) #the seed determines the starting point used in generating a sequence of pseudo random numbers #set.seed() has global scope, meaning it affects all random number generators used/called in your program.\n#there is a function to remove the seed:rm(.Random.seed, envir=.GlobalEnv)\n\nrnorm(1) #give me one number from a normal distribution\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.6264538\n```\n:::\n\n```{.r .cell-code}\nrnorm(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1836433\n```\n:::\n\n```{.r .cell-code}\nset.seed(2)\nrnorm(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.8969145\n```\n:::\n\n```{.r .cell-code}\nrnorm(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1848492\n```\n:::\n:::\n\n\nWe use `set.seed()` to make sure multiple runs of a program involving random samples give the same result, for debugging purposes.\n\nTo create a new function, `se` (standard error of means), first test if `se` exists in our current environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexists(\"se\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nNo object named `se` exists, now create the function that computes the standard error of a sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(x){\n  variance <- var(x)\n  n <-length(x)\n  return (sqrt(variance/n))\n}\n```\n:::\n\n\nObject `se` has been created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexists(\"se\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n**A side note**: how is `se` different from `sd`? They are very different! See the following [video](https://www.youtube.com/watch?v=A82brFpdr9g).\n\nCreate another function with multiple arguments:\n\n`convMeters` will convert meters to inches, feet, yards, and miles. `exists(\"convMeters\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvMeters <- function (x, to=\"inch\"){\n  factor = switch(to, inch=39.3701, foot=3.28084, yard=1.09361, mile=0.000621371, NA)\n  if(is.na(factor)) stop (\"unknown target unit\")\n  else return (x*factor)\n}\nconvMeters(23, \"foot\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 75.45932\n```\n:::\n:::\n\n\nIf no argument to is provided, the default value `'inch'` is used\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvMeters(40)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1574.804\n```\n:::\n:::\n\n\nArguments for the function can be supplied in the order as in the function signature:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvMeters(56.2, \"yard\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 61.46088\n```\n:::\n:::\n\n\nArguments can also be supplied in other orders if sufficient arguments are named so R can un-ambiguously assign the arguments for a function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvMeters(to=\"yard\", 56.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 61.46088\n```\n:::\n:::\n\n\n## Factors\n\nConceptually, factors are variables in R which take on a limited number of different values. A factor can be seen as a categorical (i.e., nominal) variable factor levels are the set of unique values the nominal variable could have. Factors are different from characters.\n\nTo create a factor, use `factor()`. Factors are represented internally as numeric vectors. This factor has two levels, `f` and `m`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <-c('f', 'm', 'f', 'f', 'f', 'm', 'm', 'f')\ng <- factor(g)\n```\n:::\n\n\nMore compact way to creating a factor with known levels, f and m:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nother.g <-factor(c('m', 'm', 'm', 'm'), levels= c('f', 'm'))\nother.g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] m m m m\nLevels: f m\n```\n:::\n:::\n\n\nCompare the above with the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nother.g <-factor(c('m', 'm', 'm', 'm'))\nother.g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] m m m m\nLevels: m\n```\n:::\n:::\n\n\nFactors are extremely useful for nominal values. Use factor to illustrate the concept of marginal frequencies or marginal distributions and `table()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- factor(c('f', 'm', 'f', 'f', 'f', 'm', 'm', 'f'))\ntable(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ng\nf m \n5 3 \n```\n:::\n:::\n\n\nAdd an age factor to the table (table can have more than two factors):\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- factor(c('adult', 'juvenile','adult', 'juvenile','adult', 'juvenile','juvenile', 'juvenile'))\ntable(a, g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na          f m\n  adult    3 0\n  juvenile 2 3\n```\n:::\n:::\n\n\nR assumes the values at the same index in the two factors are associated with the same entity. In our dataset, we have 3 female adult, 2 female juvenile, and 3 male juvenile.\n\nWhat if the a factor is not the same length as `g` factor?\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- factor(c('adult', 'juvenile','adult', 'juvenile','adult', 'juvenile','juvenile'))\ntable(a, g)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in table(a, g): all arguments must have the same length\n```\n:::\n:::\n\n\nBring the good `a` back and create a new table with factor `g`\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- factor(c('adult', 'juvenile','adult', 'juvenile','adult', 'juvenile','juvenile', 'juvenile'))\nt <- table(a, g)\nt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na          f m\n  adult    3 0\n  juvenile 2 3\n```\n:::\n:::\n\n\nFind marginal frequencies for a factor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmargin.table(t, 1)#1 refers to the first factor, a (age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\n   adult juvenile \n       3        5 \n```\n:::\n\n```{.r .cell-code}\nmargin.table(t, 2)# now find the marginal freq of the second factor g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ng\nf m \n5 3 \n```\n:::\n:::\n\n\nWe can also find relative frequencies (proportions) with respect to each margin and the overall:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na          f m\n  adult    3 0\n  juvenile 2 3\n```\n:::\n\n```{.r .cell-code}\nprop.table(t, 1) #use the margin generated for the 1st factor a \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na            f   m\n  adult    1.0 0.0\n  juvenile 0.4 0.6\n```\n:::\n:::\n\n\nAdults are all female, and among the juveniles, 40% are female and 60% are male.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(t, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na            f   m\n  adult    0.6 0.0\n  juvenile 0.4 1.0\n```\n:::\n\n```{.r .cell-code}\nprop.table(t) #overall\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na              f     m\n  adult    0.375 0.000\n  juvenile 0.250 0.375\n```\n:::\n:::\n\n\nShow the same results in percentage:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(t) * 100\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          g\na             f    m\n  adult    37.5  0.0\n  juvenile 25.0 37.5\n```\n:::\n:::\n\n\n######################################### \n\n## R data structures\n\n### Vectors\n\nThe most basic data object is a vector. One single number is a vector with a single element. All elements in one vector must be of one base data type.\n\nCreate a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(2, 5, 3, 4)\nlength(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nData type of elements in `v`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmode(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nIf you mix strings and numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(2, 5, 3, 4, 'me')\nmode(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2\"  \"5\"  \"3\"  \"4\"  \"me\"\n```\n:::\n:::\n\n\nSee the difference? All values in the `v` have now become characters strings.\n\nAll vectors can contain a special value `NA`, often used to represent a missing value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(2, 5, 3, 4, NA)\nmode(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  5  3  4 NA\n```\n:::\n:::\n\n\nA boolean vector (`TRUE`, `FALSE`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- c(TRUE, FALSE, NA, TRUE)\nmode(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE    NA  TRUE\n```\n:::\n:::\n\n\nElements in vectors are indexed starting with 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nTo update a value at a specific index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb[3] <- TRUE\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE  TRUE\n```\n:::\n:::\n\n\nVectors are elastic; you can add values to any index position:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb[10] <- FALSE\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE FALSE  TRUE  TRUE    NA    NA    NA    NA    NA FALSE\n```\n:::\n:::\n\n\nEmpty elements are filled with `NA`, as shown above\n\nCreate an empty vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <-vector()\nmode(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\ne <- c()\nmode(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NULL\"\n```\n:::\n\n```{.r .cell-code}\nlength(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nUse a vector elements to construct another vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb2 <-c(b[1], b[3], b[5])\nb2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE   NA\n```\n:::\n:::\n\n\nVectorization performs an operation on each element of a vector. It is very powerful and used widely.\n\nFind the square root of all elements in `v`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.414214 2.236068 1.732051 2.000000       NA\n```\n:::\n:::\n\n\n### Vector arithmetic\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(3, 6, 9)\nv2 <- c(1, 4, 8)\nv1+v2 #addition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 10 17\n```\n:::\n\n```{.r .cell-code}\nv1*v2 #dot product\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3 24 72\n```\n:::\n\n```{.r .cell-code}\nv1-v2 #subtraction\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2 1\n```\n:::\n\n```{.r .cell-code}\nv1/v2 #divsion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.000 1.500 1.125\n```\n:::\n:::\n\n\n**Warning**: arithmetic with vectors of different sizes is allowed in R. R uses recycling rule to make the shorter vector the same length as the longer vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv3 <- c(1, 4)\nv1+v3#the recycling rule makes v3 [1, 4, 1]\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in v1 + v3: longer object length is not a multiple of shorter object\nlength\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 10 10\n```\n:::\n:::\n\n\nRemember, a single value is a vector too?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2*v1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6 12 18\n```\n:::\n:::\n\n\n### Vector summary:\n\nElements are of same data type, elastic, vectorization, arithmetic operations and the recycling rule.\n\nUse vector to illustrate \"for\" loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmysum <- function (x){\n  sum <- 0\n  for(i in 1:length(x)){\n    sum <- sum + x[i]\n  }\n  return (sum)\n}\n\n(mysum (c(1, 2, 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n# PART II\n\n## Easy ways to generate vectors\n\nThese are useful when you need to generate some data with known distribution to test certain functions.\n\nUse `()` to print the result of a statement in the console `1 2 3 4 5 6 7 8 9 10`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <-1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\n(x <-10:1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n:::\n:::\n\n\nNote the precedence of the operator `:` is higher than arithmetic operators. Observe the difference below, why they give different results?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n10:15-1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  9 10 11 12 13 14\n```\n:::\n\n```{.r .cell-code}\n10:(15-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 11 12 13 14\n```\n:::\n:::\n\n\nUse `seq()` to generate sequence with real numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(seq(from=1, to=5, length=4)) # 4 values between 1 and 5 inclusive, even intervals/steps\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.000000 2.333333 3.666667 5.000000\n```\n:::\n\n```{.r .cell-code}\n(seq(length=10, from=-2, by=0.5)) #10 values, starting from 2, interval/step = 0.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5\n```\n:::\n:::\n\n\nUse `rep(x, n)`: repeat `x` `n` times:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rep(5, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 5 5 5 5 5 5 5 5 5 5\n```\n:::\n\n```{.r .cell-code}\n(rep(\"hi\", 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hi\" \"hi\" \"hi\"\n```\n:::\n:::\n\n\n`1 2 1 2 1 2`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rep(1:2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 1 2 1 2\n```\n:::\n\n```{.r .cell-code}\n(rep(TRUE:FALSE, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0 1 0 1 0\n```\n:::\n:::\n\n\n`1 1 1 2 2 2`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rep(1:2, each=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 2 2 2\n```\n:::\n:::\n\n\n`gl()` is for generating factor levels:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngl(3, 5) #three levels, each repeat 5 times\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\nLevels: 1 2 3\n```\n:::\n\n```{.r .cell-code}\ngl(2, 5, labels= c('female', 'male'))#two levels, each level repeat 5 times\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] female female female female female male   male   male   male   male  \nLevels: female male\n```\n:::\n\n```{.r .cell-code}\n#first argument 2 says two levels. \n#second argument 1 says repeat once\n#third argment 20 says generate 20 values\ngl(2, 1, 20, labels=c('female', 'male'))#10 alternating female and male pairs, a total of 20 values.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] female male   female male   female male   female male   female male  \n[11] female male   female male   female male   female male   female male  \nLevels: female male\n```\n:::\n:::\n\n\nUse `factor()` to convert number sequence to factor level labels. This is very useful for labeling a dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- rep(1:2, each=3)\n(n <- factor(n, \n             levels = c(1, 2),\n             labels = c('female','male')\n             ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] female female female male   male   male  \nLevels: female male\n```\n:::\n\n```{.r .cell-code}\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] female female female male   male   male  \nLevels: female male\n```\n:::\n:::\n\n\nGenerate random data according to some probability density functions: the functions has a general signature of `rfunc(n, par1, par2, …)`\n\n`r` for random,`func` is the name of the density function, `n` is the length of the data to be generated, `par1`, `par2`, `…` are the parameters needed for a density function\n\nGenerate 10 values following a `normal distribution` with `mean = 10` and `standard deviation = 3`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rnorm(10, mean=10, sd=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 14.763536  6.608873  9.759245 10.397261 12.123864  9.280906 15.953422\n [8]  9.583639 11.252952 12.945258\n```\n:::\n\n```{.r .cell-code}\n(rt(10, df=5)) #10 values following a Student T distribution with degree of freedom of 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -0.69423122 -1.90338399  0.02947754  0.27787640 -0.85885978  2.18155848\n [7] -2.34536097 -0.52103705  0.25674735  0.25832186\n```\n:::\n:::\n\n\n**Exercise**:\n\n\\(1\\) Generate a random sample of `normally distributed` data of `size 100`, with a `mean of 20` and `standard deviation 4`\n\n\\(2\\) Compute the standard error of means of the dataset.\n\n## Summary on vector generation:\n\nrange, seq, rep, gl, and distribution based random data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample <- rnorm(100, mean=20, sd=4)\nse(sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.446371\n```\n:::\n:::\n\n\n## Sub-setting\n\nFlexible ways of select values from a vector.\n\nUse boolean operators:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, -3, 4, -1, 45, 90, -5)\n#select all elements that is greater than 0\n(gtzero <- x[x>0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 45 90\n```\n:::\n:::\n\n\nUse `|` (or), and `&` (and) operators:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, -3, 4, -1, 45, 90, -5)\n(x[x<=-2 | x>5])\t\t\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3 45 90 -5\n```\n:::\n\n```{.r .cell-code}\n(x[x>40 & x<100])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45 90\n```\n:::\n:::\n\n\nUse a vector index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, -3, 4, -1, 45, 90, -5)\n(x[c(4, 6)])#select the 4th and 6th elements in the vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 90\n```\n:::\n\n```{.r .cell-code}\n(y<-c(4,6)) #same as above\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6\n```\n:::\n\n```{.r .cell-code}\n(x[y])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 90\n```\n:::\n\n```{.r .cell-code}\n(x[1:3]) #select the 1st to the 3rd elements in the vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0 -3  4\n```\n:::\n:::\n\n\nUse negative index to exclude elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, -3, 4, -1, 45, 90, -5)\n(x[-1]) #select all but the first element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3  4 -1 45 90 -5\n```\n:::\n\n```{.r .cell-code}\n(x[-c(4, 6)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0 -3  4 45 -5\n```\n:::\n\n```{.r .cell-code}\n(x[-(1:3)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 45 90 -5\n```\n:::\n:::\n\n\n### Named elements\n\nElements in a vector can have names.\n\nAssign names to vector elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, -3, 4, -1, 45, 90, -5)\nnames(x) <- c('s1', 's2', 's3', 's4', 's5', 's6', 's7')\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ns1 s2 s3 s4 s5 s6 s7 \n 0 -3  4 -1 45 90 -5 \n```\n:::\n:::\n\n\nCreate a vector with named elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(pH <- c(area1=4.5, area2=5.7, area3=9.8, mud=7.2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narea1 area2 area3   mud \n  4.5   5.7   9.8   7.2 \n```\n:::\n:::\n\n\nUse individual names to reference/select elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npH['mud']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmud \n7.2 \n```\n:::\n\n```{.r .cell-code}\npH[c('area1', 'mud')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narea1   mud \n  4.5   7.2 \n```\n:::\n:::\n\n\n...but can not use directly element names to exclude or select a range of elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-s1] #results in error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 's1' not found\n```\n:::\n\n```{.r .cell-code}\nx[-\"s1\"] #results in error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in -\"s1\": invalid argument to unary operator\n```\n:::\n\n```{.r .cell-code}\nx[s1:s7] #results in error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 's1' not found\n```\n:::\n\n```{.r .cell-code}\nx[c('s1':'s7')] #results in error\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in \"s1\":\"s7\": NA/NaN argument\n```\n:::\n:::\n\n\nEmpty index means to select all:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npH[]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narea1 area2 area3   mud \n  4.5   5.7   9.8   7.2 \n```\n:::\n\n```{.r .cell-code}\npH\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narea1 area2 area3   mud \n  4.5   5.7   9.8   7.2 \n```\n:::\n:::\n\n\nUse this method to reset a vector to 0:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npH[] <- 0\npH\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narea1 area2 area3   mud \n    0     0     0     0 \n```\n:::\n\n```{.r .cell-code}\npH<- 0\npH\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nThis is different from `pH <- 0`, why?\n\n### Sub-setting summary:\n\nboolean tests, index-based selection/exclusion, name-based selection\n\n## More R Data Structures\n\n### Matrices and Arrays\n\nArrays and matrices are essentially long vectors ***organized*** by dimensions.\n\nArrays can be multiple dimensions, while matrices are two dimensional, but they hold same type of values.\n\n#### Matrices\n\nTo create a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23)\nis.vector(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.array(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n#then 'organize' the vector as a matrix\ndim(m) <-c(2, 5)#make the vector a 2 by 5 matrix, 2x5 must = lenght of the vector\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   23   77   44   12   23\n```\n:::\n\n```{.r .cell-code}\nis.vector(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.array(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nBy default, the elements are put in matrix by columns. Use `byrow=TRUE` to do it the other way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(m <- matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5, byrow = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   23   66   77   33\n[2,]   44   56   12   78   23\n```\n:::\n:::\n\n\n**Exercise:**\n\nCreate a matrix with two columns:\n\nFirst columns hold age data for a group of students `11, 11, 12, 13, 14, 9, 8`, and second columns hold grades `5, 5, 6, 7, 8, 4, 3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <-matrix(c(11, 11, 12, 13, 14, 9, 8, 5, 5, 6, 7, 8, 4, 3), 7, 2)\ntest\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   11    5\n[2,]   11    5\n[3,]   12    6\n[4,]   13    7\n[5,]   14    8\n[6,]    9    4\n[7,]    8    3\n```\n:::\n:::\n\n\nAccess matrix elements using position indexes (again, index starting from 1):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23)\n#then 'organize' the vector as a matrix\ndim(m) <- c(2, 5)#make the vector a 2 by 5 matrix, 2x5 must = lenght of the vector\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   45   66   33   56   78\n[2,]   23   77   44   12   23\n```\n:::\n\n```{.r .cell-code}\nm[2, 3]#the element at row 2 and column 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 44\n```\n:::\n:::\n\n\nSub-setting a matrix is similar to sub-setting on a vector.\n\nThe result is a value (a value is a vector), a vector, or a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(s<- m[2, 1]) # select one value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23\n```\n:::\n\n```{.r .cell-code}\n(m<- m [c(1,2), -c(3, 5)]) #select 1st row and 1st, 2nd, and 4th columns: result is a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   45   66   56\n[2,]   23   77   12\n```\n:::\n\n```{.r .cell-code}\n(m [1, ]) #select complete row or column: 1st row, result is a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45 66 56\n```\n:::\n\n```{.r .cell-code}\n(v<-m [, 1]) # 1st column, result is a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45 23\n```\n:::\n\n```{.r .cell-code}\nis.vector(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.vector(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.vector(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nUse `drop = FALSE` to keep the results as a matrix (not vectors like shown above)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)\n(m<-m [, 2, drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]   66\n[2,]   77\n```\n:::\n\n```{.r .cell-code}\nis.matrix(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.vector(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n`cbind()` and `rbind()`: join together two or more vectors or matrices, by column, or by row, respectively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind (c(1,2,3), c(4, 5, 6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n\n```{.r .cell-code}\nrbind (c(1,2,3), c(4, 5, 6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n:::\n\n```{.r .cell-code}\nm <- matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)\n(a <- rbind (c(1,2,3,4,5), m))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]   45   66   33   56   78\n[3,]   23   77   44   12   23\n```\n:::\n\n```{.r .cell-code}\nis.array(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n**Exercise**:\n\nWhat will `m1-m4` look like?\n\n``` r\nm1 <- matrix(rep(10, 9), 3, 3) m2 <- cbind (c(1,2,3), c(4, 5, 6)) m3 <- cbind (m1[,1], m2[2,]) m4 <- cbind (m1[,1], m2[,2])\n```\n\n#### Named rows and columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales <- matrix(c(10, 30, 40, 50, 43, 56, 21, 30), 2, 4, byrow=TRUE)\ncolnames(sales) <- c('1qrt', '2qrt', '3qrt', '4qrt')\nrownames(sales) <- c('store1', 'store2')\nsales\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       1qrt 2qrt 3qrt 4qrt\nstore1   10   30   40   50\nstore2   43   56   21   30\n```\n:::\n:::\n\n\n**Exercise**:\n\nFind `store1` `1qrt` sale. 2. List `store2`'s 1st and 4th quarter sales:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales['store1', '1qrt']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nsales['store2', c('1qrt', '4qrt')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1qrt 4qrt \n  43   30 \n```\n:::\n:::\n\n\n#### Arrays\n\nArrays are similar to matrices, but arrays can have more than 2 dimensions\n\n3-D array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- array(1:48, dim= c(4, 3, 2))\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   13   17   21\n[2,]   14   18   22\n[3,]   15   19   23\n[4,]   16   20   24\n```\n:::\n:::\n\n\nSelect array elements using indexes, results may be a value, a vector, a matrix or an array, depending on the use of `drop=FALSE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na [1, 3, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n\n```{.r .cell-code}\na [1, , 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13 17 21\n```\n:::\n\n```{.r .cell-code}\na [1, , 2, drop=FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]   13   17   21\n```\n:::\n\n```{.r .cell-code}\na [4, 3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12 24\n```\n:::\n\n```{.r .cell-code}\na [c(2, 3), , -2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    6   10\n[2,]    3    7   11\n```\n:::\n:::\n\n\nAssign names to dimensions of an array.\n\n`[[]]` selects one dimension:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndimnames(a)[[1]] <-c(\"1qrt\", \"2qrt\", \"3qrt\", \"4qrt\")\ndimnames(a)[[2]] <-c(\"store1\", \"store2\", \"store3\")\ndimnames(a)[[3]] <-c(\"2017\", \"2018\")\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 2017\n\n     store1 store2 store3\n1qrt      1      5      9\n2qrt      2      6     10\n3qrt      3      7     11\n4qrt      4      8     12\n\n, , 2018\n\n     store1 store2 store3\n1qrt     13     17     21\n2qrt     14     18     22\n3qrt     15     19     23\n4qrt     16     20     24\n```\n:::\n:::\n\n\nAlternatively, use `list()` to specify names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nar <- array(data     = 1:27,\n            dim      = c(3, 3, 3),\n            dimnames = list(c(\"a\", \"b\", \"c\"),                                                                    c(\"d\", \"e\", \"f\"),                                                                       c(\"g\", \"h\", \"i\")))\nar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , g\n\n  d e f\na 1 4 7\nb 2 5 8\nc 3 6 9\n\n, , h\n\n   d  e  f\na 10 13 16\nb 11 14 17\nc 12 15 18\n\n, , i\n\n   d  e  f\na 19 22 25\nb 20 23 26\nc 21 24 27\n```\n:::\n:::\n\n\n#### Split array into matrices\n\nPerform arithmetic operations on matrices, note the recycling rules apply:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1 <- ar[,,g]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1 <- ar[,,'g']\nmatrix1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d e f\na 1 4 7\nb 2 5 8\nc 3 6 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix2 <- ar[,,'h']\nmatrix2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   d  e  f\na 10 13 16\nb 11 14 17\nc 12 15 18\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum <-matrix1 + matrix2\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   d  e  f\na 11 17 23\nb 13 19 25\nc 15 21 27\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1*3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d  e  f\na 3 12 21\nb 6 15 24\nc 9 18 27\n```\n:::\n:::\n\n\nA matrix is just a long vector organized into dimensions, note the recycling rules apply:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d e f\na 1 4 7\nb 2 5 8\nc 3 6 9\n```\n:::\n\n```{.r .cell-code}\nmatrix1*c(2, 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in matrix1 * c(2, 3): longer object length is not a multiple of shorter\nobject length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  d  e  f\na 2 12 14\nb 6 10 24\nc 6 18 18\n```\n:::\n\n```{.r .cell-code}\nmatrix1*c(2,3,2,3,2,3,2,3,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d  e  f\na 2 12 14\nb 6 10 24\nc 6 18 18\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1*c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d  e  f\na 1  4  7\nb 4 10 16\nc 9 18 27\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix1/c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d   e f\na 1 4.0 7\nb 1 2.5 4\nc 1 2.0 3\n```\n:::\n\n```{.r .cell-code}\nmatrix1/c(1, 2, 3, 1, 2, 3, 1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d   e f\na 1 4.0 7\nb 1 2.5 4\nc 1 2.0 3\n```\n:::\n:::\n\n\n### Lists\n\nLists are vectors too, but they are 'recursive' (as opposed to the 'atomic' vectors we learned before: vector, matrix, arrays), meaning they can hold other lists, meaning a list can hold data of different types. Lists consist of an ordered collection of objects known as their components ##list components do not need to be of the same type. ##list components are always numbered (with an index) and may also have a name attached to them.\n\nUse `list$component_name` to access a component in a *list* can not be used on atomic vectors.\n\n`[`, `[[`, and `$`: <https://www.r-bloggers.com/r-accessors-explained/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(stud.id=34453,\n               stud.name=\"John\",\n               stud.marks= c(13, 3, 12, 15, 19)\n               )\n\nmylist$stud.id\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 34453\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$stud.id\n[1] 34453\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 34453\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[\"stud.id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$stud.id\n[1] 34453\n```\n:::\n\n```{.r .cell-code}\nhandle <- \"stud.id\"\nmylist[handle]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$stud.id\n[1] 34453\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[[\"stud.id\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 34453\n```\n:::\n:::\n\n\n### Subset with `[`\n\nBoth indices and names can be used to extract the subset. In order to use names, object must have a name type attribute such as names, rownames, colnames, etc.\n\nYou can use negative integers to indicate exclusion.\n\nUnquoted variables are interpolated within the brackets.\n\n### Extract one item with `[[`\n\nThe double square brackets are used to extract one element from potentially many. For vectors yield vectors with a single value; data frames give a column vector; for list, one element\n\nYou can return only one item. The result is not (necessarily) the same type of object as the container. The dimension will be the dimension of the one item which is not necessarily 1. And, as before: Names or indices can both be used. #Variables are interpolated.\n\n### Interact with `$`\n\n`$` is a special case of `[[` in which you access a single item by actual name (but not used for atomic vectors). You cannot use integer indices.\n\nThe name will not be interpolated and returns only one item. If the name contains special characters, the name must be enclosed in back-ticks: `\"`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(stud.id=34453,\n               stud.name=\"John\",\n               stud.marks= c(13, 3, 12, 15, 19)\n               )\nmylist$stud.marks\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13  3 12 15 19\n```\n:::\n\n```{.r .cell-code}\nmylist$stud.marks[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nChange names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"stud.id\"    \"stud.name\"  \"stud.marks\"\n```\n:::\n\n```{.r .cell-code}\nnames(mylist) <- c('id','name','marks')\n\nnames(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"id\"    \"name\"  \"marks\"\n```\n:::\n\n```{.r .cell-code}\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$id\n[1] 34453\n\n$name\n[1] \"John\"\n\n$marks\n[1] 13  3 12 15 19\n```\n:::\n:::\n\n\nAdd new component:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist$parents.names <- c('Ana', \"Mike\")\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$id\n[1] 34453\n\n$name\n[1] \"John\"\n\n$marks\n[1] 13  3 12 15 19\n\n$parents.names\n[1] \"Ana\"  \"Mike\"\n```\n:::\n:::\n\n\nUse `c()` to concatenate two lists:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewlist <- list(age=19, sex=\"male\");\nexpandedlist <-c(mylist, newlist)\nexpandedlist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$id\n[1] 34453\n\n$name\n[1] \"John\"\n\n$marks\n[1] 13  3 12 15 19\n\n$parents.names\n[1] \"Ana\"  \"Mike\"\n\n$age\n[1] 19\n\n$sex\n[1] \"male\"\n```\n:::\n\n```{.r .cell-code}\nlength(expandedlist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n### Remove list components using negative index, or using NULL\n\n**Exercise:**\n\nStarting with the expanded list given above, what will be the result of the following statement? Consider the statement one by one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpandedlist <- expandedlist[-5]\nexpandedlist <- expandedlist[c(-1,-5)]\nexpandedlist$parents.names <- NULL\nexpandedlist[['marks']] <- NULL\n```\n:::\n\n\n`unlist()` coerces a list to a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$id\n[1] 34453\n\n$name\n[1] \"John\"\n\n$marks\n[1] 13  3 12 15 19\n\n$parents.names\n[1] \"Ana\"  \"Mike\"\n```\n:::\n\n```{.r .cell-code}\nunlist(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            id           name         marks1         marks2         marks3 \n       \"34453\"         \"John\"           \"13\"            \"3\"           \"12\" \n        marks4         marks5 parents.names1 parents.names2 \n          \"15\"           \"19\"          \"Ana\"         \"Mike\" \n```\n:::\n\n```{.r .cell-code}\nmode(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nmode(unlist(mylist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nis.vector(unlist(mylist)) #atomic list with names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.list(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.atomic(mylist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.list(unlist(mylist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## Data Frames\n\nThe recommended data structure for tables (2-D), data frames are a special kind of list: each row is an observation, each column is an attribute.\n\nThe column names should be non-empty, and the row names should be unique.\n\nThe data stored in a data frame can be of numeric, factor or character type., and each column should contain same number of data items.\n\n### Create a data frame\n\n*Note*: dataframe turns categorical values to a factor by default\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.dataframe <- data.frame(site=c('A', 'B', 'A','A', 'B'),\n                           season=c('winter', 'summer', 'summer', 'spring', 'fall'),                               ph = c(7.4, 6.3, 8.6, 7.2, 8.9))\nmy.dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site season  ph\n1    A winter 7.4\n2    B summer 6.3\n3    A summer 8.6\n4    A spring 7.2\n5    B   fall 8.9\n```\n:::\n:::\n\n\nDifferent ways to access the elements in a dataframe (table): `[]`, `[[]]`, `$`,\n\n### Indexes and names\n\n**Exercise:**\n\nGiven \\`my.dataframes\\`, what values will the following statements access?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.dataframe <- data.frame(site=c('A', 'B', 'A','A', 'B'),\n                           season=c('winter', 'summer', 'summer', 'spring', 'fall'),                               ph = c(7.4, 6.3, 8.6, 7.2, 8.9))\nmy.dataframe[3, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"summer\"\n```\n:::\n\n```{.r .cell-code}\nmy.dataframe[['site']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"B\" \"A\" \"A\" \"B\"\n```\n:::\n\n```{.r .cell-code}\nmy.dataframe['site']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site\n1    A\n2    B\n3    A\n4    A\n5    B\n```\n:::\n\n```{.r .cell-code}\nmy.dataframe[my.dataframe$ph>7, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site season  ph\n1    A winter 7.4\n3    A summer 8.6\n4    A spring 7.2\n5    B   fall 8.9\n```\n:::\n\n```{.r .cell-code}\nmy.dataframe[my.dataframe$ph>7, 'site']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"A\" \"A\" \"B\"\n```\n:::\n\n```{.r .cell-code}\nmy.dataframe[my.dataframe$ph>7, c('site', 'ph')]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site  ph\n1    A 7.4\n3    A 8.6\n4    A 7.2\n5    B 8.9\n```\n:::\n:::\n\n\n### Use `subset()` to query a data frame\n\n`subset()` can only query, it can not be used to change values in the data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(my.dataframe, ph>7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site season  ph\n1    A winter 7.4\n3    A summer 8.6\n4    A spring 7.2\n5    B   fall 8.9\n```\n:::\n\n```{.r .cell-code}\nsubset(my.dataframe, ph>7, c(\"site\", \"ph\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site  ph\n1    A 7.4\n3    A 8.6\n4    A 7.2\n5    B 8.9\n```\n:::\n\n```{.r .cell-code}\nsubset(my.dataframe[1:2,], ph>7, c(site, ph))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site  ph\n1    A 7.4\n```\n:::\n:::\n\n\nTo change values in data frame - add 1 to `summer` `ph`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.dataframe[my.dataframe$season=='summer', 'ph'] <- my.dataframe[my.dataframe$season=='summer', 'ph'] + 1 \n                                                                  my.dataframe[my.dataframe$season=='summer', 'ph']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.3 9.6\n```\n:::\n\n```{.r .cell-code}\nmy.dataframe[my.dataframe$season=='summer' & my.dataframe$ph>8, 'ph'] <- my.dataframe[my.dataframe$season=='summer' & my.dataframe$ph>8, 'ph'] + 1                                                              \n        \nmy.dataframe[my.dataframe$season=='summer', 'ph']                             \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7.3 10.6\n```\n:::\n:::\n\n\n### Add a column\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.dataframe$NO3 <- c(234.5, 123.4, 456.7, 567.8, 789.0)\nmy.dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site season   ph   NO3\n1    A winter  7.4 234.5\n2    B summer  7.3 123.4\n3    A summer 10.6 456.7\n4    A spring  7.2 567.8\n5    B   fall  8.9 789.0\n```\n:::\n:::\n\n\nHow do you remove a column?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#my.dataframe$NO3<-NULL\nmy.dataframe <- my.dataframe[, -4]\nmy.dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  site season   ph\n1    A winter  7.4\n2    B summer  7.3\n3    A summer 10.6\n4    A spring  7.2\n5    B   fall  8.9\n```\n:::\n:::\n\n\nCheck the structure of a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my.dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5 obs. of  3 variables:\n $ site  : chr  \"A\" \"B\" \"A\" \"A\" ...\n $ season: chr  \"winter\" \"summer\" \"summer\" \"spring\" ...\n $ ph    : num  7.4 7.3 10.6 7.2 8.9\n```\n:::\n\n```{.r .cell-code}\nnrow(my.dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nncol(my.dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ndim(my.dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3\n```\n:::\n:::\n\n\nEdit a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n edit(my.dataframe) #this brings up a data editor\n\n View(my.dataframe) #this brings up a uneditable tab that display the data for you to view.\n```\n:::\n\n\nUpdate names of the columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(my.dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"site\"   \"season\" \"ph\"    \n```\n:::\n\n```{.r .cell-code}\nnames(my.dataframe) <- c('area', 'season', 'P.h.')\nmy.dataframe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  area season P.h.\n1    A winter  7.4\n2    B summer  7.3\n3    A summer 10.6\n4    A spring  7.2\n5    B   fall  8.9\n```\n:::\n\n```{.r .cell-code}\nnames(my.dataframe)[3] <- 'ph'\nmy.dataframe \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  area season   ph\n1    A winter  7.4\n2    B summer  7.3\n3    A summer 10.6\n4    A spring  7.2\n5    B   fall  8.9\n```\n:::\n:::\n\n\n## Tibbles\n\nTibbles are similar to data frame, but they are more convenient than data frame.\n\nColumns can be defined based on other columns defined earlier. Tibbles cannot convert categorical valued attributes to factors and does not print an entire dataset (when it is large, it occupied all your screen and more).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tibble\")\n                                                                  library(tibble)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n### Create a tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.tibble <- tibble(TempCels = sample(-10:40, size=100, replace=TRUE), \n                    TempFahr = TempCels*9/5+32,\n                    Location = rep(letters[1:2], each=50))\nmy.tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 × 3\n   TempCels TempFahr Location\n      <int>    <dbl> <chr>   \n 1       16     60.8 a       \n 2       -5     23   a       \n 3       31     87.8 a       \n 4       -4     24.8 a       \n 5        7     44.6 a       \n 6       -3     26.6 a       \n 7       12     53.6 a       \n 8       25     77   a       \n 9      -10     14   a       \n10       25     77   a       \n# ℹ 90 more rows\n```\n:::\n:::\n\n\nUse the penguins data frame from the `palmerpenguins` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\ndata(penguins)\ndim(penguins)\nclass(penguins)\npenguins\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 344   8\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n:::\n\n\n### Convert a data frame to a tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\npe <-as_tibble(penguins)\nclass(pe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\npe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n:::\n\n\n*Note*: you can use `print(pe, n=Inf, width=Inf)` to print the entire `pe` dataset.\n\n`mode` is a mutually exclusive classification of objects according to their basic structure. The 'atomic' modes are numeric, complex, character and logical. Recursive objects have modes such as 'list' or 'function' or a few others. An object has one and only one mode.\n\n`class` is a property assigned to an object that determines how generic functions operate with it. It is not a mutually exclusive classification. If an object has no specific class assigned to it, such as a simple numeric vector, it's class is usually the same as its mode, by convention.\n\nChanging the mode of an object is often called 'coercion'. The mode of an object can change without necessarily changing the class.\n\ne.g., typeof or specific type testers: is.vector, is.atomic, is.data.frame, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:16\nmode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ndim(x) <- c(4,4)\nclass(x) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\nis.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nmode(x) <- \"character\"\nmode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\n#mode changed from 'numeric' to 'character', but class stays 'matrix'    \n```\n:::\n\n\nHowever:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(x)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nmode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\n#class changed from 'matrix' to 'factor', but mode stays 'numeric'  \n#At this stage, even though x has mode numeric again, its new class, 'factor', prohibits it being used in arithmetic operations.\n```\n:::\n\n\nA set of \\`is.xxx()\\` functions can be used to check the data structure of an object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.array(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.list(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.matrix(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_tibble(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.vector(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\nSubsetting a tibble results in a smaller tibble\n\n*Note*: this is different from data frame -- subsetting a data frame could result in a vector, when subsetting result in one or one series of values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pe[1:15, c(\"bill_length_mm\", \"bill_depth_mm\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(penguins[1:15, c(\"bill_length_mm\", \"bill_depth_mm\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(pe[1:15, c(\"bill_length_mm\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(penguins[1:15, c(\"bill_length_mm\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\n\n### R data structure summary:\n\nhttp://adv-r.had.co.nz/Data-structures.html\n\n## `dplyr`\n\n`dplyr` library is very useful for manipulate table-like data: <https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html>\n\n### Data wrangling cheatsheet\n\n<https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf>\n\n### `filter()` vs. `select()`\n\n`select()` selects a subset of columns of the dataset.\n\n`filter()` select a subset of rows.\n\nThese two are often used in a nested fashion (like SQL SELECT/WHERE)\n\nOther useful functions provided by `dplyr:mutate`, `summarise`, `arrange`, and joins (e.g,. `left_join()`, `right_join()`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dplyr\")\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nSelect bill lengths and widths of species `Adelie`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(filter(pe, species==\"Adelie\"), bill_length_mm, bill_depth_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 × 2\n   bill_length_mm bill_depth_mm\n            <dbl>         <dbl>\n 1           39.1          18.7\n 2           39.5          17.4\n 3           40.3          18  \n 4           NA            NA  \n 5           36.7          19.3\n 6           39.3          20.6\n 7           38.9          17.8\n 8           39.2          19.6\n 9           34.1          18.1\n10           42            20.2\n# ℹ 142 more rows\n```\n:::\n\n```{.r .cell-code}\nfilter(select(pe, bill_length_mm, bill_depth_mm, species), species==\"Adelie\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 × 3\n   bill_length_mm bill_depth_mm species\n            <dbl>         <dbl> <fct>  \n 1           39.1          18.7 Adelie \n 2           39.5          17.4 Adelie \n 3           40.3          18   Adelie \n 4           NA            NA   Adelie \n 5           36.7          19.3 Adelie \n 6           39.3          20.6 Adelie \n 7           38.9          17.8 Adelie \n 8           39.2          19.6 Adelie \n 9           34.1          18.1 Adelie \n10           42            20.2 Adelie \n# ℹ 142 more rows\n```\n:::\n:::\n\n\n**Exercise**\n\nHow would you achieve the same result as the above but use tibble subsetting?\n\n\n::: {.cell}\n\n```{.r .cell-code}\npe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n\n```{.r .cell-code}\npe[pe$species=='Adelie', c(\"bill_length_mm\", \"bill_depth_mm\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 × 2\n   bill_length_mm bill_depth_mm\n            <dbl>         <dbl>\n 1           39.1          18.7\n 2           39.5          17.4\n 3           40.3          18  \n 4           NA            NA  \n 5           36.7          19.3\n 6           39.3          20.6\n 7           38.9          17.8\n 8           39.2          19.6\n 9           34.1          18.1\n10           42            20.2\n# ℹ 142 more rows\n```\n:::\n\n```{.r .cell-code}\nsubset(pe, pe$species=='Adelie', c(\"bill_length_mm\", \"bill_depth_mm\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 × 2\n   bill_length_mm bill_depth_mm\n            <dbl>         <dbl>\n 1           39.1          18.7\n 2           39.5          17.4\n 3           40.3          18  \n 4           NA            NA  \n 5           36.7          19.3\n 6           39.3          20.6\n 7           38.9          17.8\n 8           39.2          19.6\n 9           34.1          18.1\n10           42            20.2\n# ℹ 142 more rows\n```\n:::\n:::\n\n\nPipe `|>`, or the `magrittr` `%>%`, passes the output of a function to another function as its first argument.\n\nVery handy and widely used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(pe, bill_length_mm, bill_depth_mm, species) |> filter(species==\"Adelie\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 × 3\n   bill_length_mm bill_depth_mm species\n            <dbl>         <dbl> <fct>  \n 1           39.1          18.7 Adelie \n 2           39.5          17.4 Adelie \n 3           40.3          18   Adelie \n 4           NA            NA   Adelie \n 5           36.7          19.3 Adelie \n 6           39.3          20.6 Adelie \n 7           38.9          17.8 Adelie \n 8           39.2          19.6 Adelie \n 9           34.1          18.1 Adelie \n10           42            20.2 Adelie \n# ℹ 142 more rows\n```\n:::\n:::\n\n\n**Exercise**\n\nPass the result from the filter to the select function and achieve the same result as shown above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(pe, species==\"Adelie\") |> select(bill_length_mm, bill_depth_mm, species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 152 × 3\n   bill_length_mm bill_depth_mm species\n            <dbl>         <dbl> <fct>  \n 1           39.1          18.7 Adelie \n 2           39.5          17.4 Adelie \n 3           40.3          18   Adelie \n 4           NA            NA   Adelie \n 5           36.7          19.3 Adelie \n 6           39.3          20.6 Adelie \n 7           38.9          17.8 Adelie \n 8           39.2          19.6 Adelie \n 9           34.1          18.1 Adelie \n10           42            20.2 Adelie \n# ℹ 142 more rows\n```\n:::\n:::\n\n\n**Exercise**\n\nCreate a data object to hold student names (`Judy`, `Max`, `Dan`) and their grades (\\`78`,`85`,`99`) Convert number grades to letter grades:`90-100`:`A`;`80-89`:`B`;`70-79`:`C`; \\`\\<70`:`F\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- list(names=c(\"Judy\", \"Max\", \"Dan\"),\n                 grades=c(78, 85, 99))\nprint (\"before:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"before:\"\n```\n:::\n\n```{.r .cell-code}\nstudents\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"Judy\" \"Max\"  \"Dan\" \n\n$grades\n[1] 78 85 99\n```\n:::\n\n```{.r .cell-code}\ngradeConvertor<- function (grade){\n  grade = as.numeric(grade)\n  if(grade > 100 | grade < 0) print (\"grade out of the range\")\n  else if(grade >= 90 & grade <= 100) return (\"A\")\n  else if(grade >= 80 & grade < 90) return (\"B\")\n  else if(grade >= 70 & grade < 80) return (\"C\")\n  else return (\"F\")\n}\n\n#students$grades <-sapply(students$grades, gradeConvertor)\n\nfor(i in 1:length(students$grades)){\n  students$grades[i] = gradeConvertor(students$grades[i])\n}\n\nprint (\"after:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"after:\"\n```\n:::\n\n```{.r .cell-code}\nstudents\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"Judy\" \"Max\"  \"Dan\" \n\n$grades\n[1] \"C\" \"B\" \"A\"\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}